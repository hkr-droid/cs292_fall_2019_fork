\section{Methodology}

In this project we followed the paradigm presented in the first homework assignment which demonstrated Rosette as a solver-aided programming language.  To that end, we designed a DSL (domain-specific language) to simulate features of a concurrent programming language, using as a starting point the toy language Imp. Our main contributions to the language were adding the \texttt{par} and \texttt{atomic} operators which give us the semantic notion of concurrency, and an interpreter which offers a way to simulate a non-deterministic environment.  With these additions, we simulated a form of concurrency by being able to interleave commands at the will of a scheduler built into our interpreter.  We will elaborate on the design of our language by using the following code snippet as an example.  It is based on a midterm question used in the CS170 class.

\subsection{Imp as a DSL}
Rosette requires the user to provide a specification language that it can use to lift and convert ultimately into logical SMT formulas.  We chose Imp because it afforded the basic features necessary to test concurrent semantics, namely integer arithmetic and logical sequencing.  There are a number of examples and tutorials using custom DSLs  in the lectures of James Bornholt and Emina Torlak.  These however used fairly simple languages and could not ultimately provide the level of detail we needed to employ Rosette to any degree of utility with our own concurrent language.

\subsubsection{Big-Step Semantics}
We first implemented Imp using a big-step style semantics. The big-step style is exemplified by having a simple recursive function evaluate all terms in a given expression until termination.  This can be straightforwardly accomplished by giving the terms of the language as ground functions of integer arity, and pattern matching over them.  The advantages of this approach are its simplicity and ease of setup.  There are disadvantages though in how the evaluation procedure is a monolithic function call.  That is, there was no way to inspect a single step of the evaluation, which is nececssary to do more complicated control-flow procedures.

\subsubsection{Small-Step Semantics}
To remedy the above shortcomings, we realized we needed to adopt a more granular approach to evaluating expressions.  The programming languages community defines an analogue to the big-step style, appropriately termed ``small-step semantics.''  In this protocol, the recursion is modded out and each pattern match, instead of \emph{destructing} a given term, \emph{contructs} a data structure representing the state of the overall evaluation.  A common notion of state used in the literature comes from the notion of an abstract machine.

Abstract machines are an approach to operational semantics that centralize the notion of registers, so that temporary evaluations of code, ad future directions of evaluation, are stored in registers as if they were stacks.   The tradition began with Peter Landin's SECD machine and was redesigned by Matthias Fellesen under the CESK moniker, an acronym that stands for (C)ontrol, (E)nvironment, (S)tore, (K)ontinutation.  We adopted the CESK approach to rebuilding our interpreter in the small-step  style.

\subsubsection{Par and Atomic}
After reimplementing our language as an abstract CESK machine, we had only really mimiced the functionality that we already had with the big-step semantics.  However, we could implement the \texttt{par} and \texttt{atomic} functions in the above style.

To some extent, we combined the interpreter and the semantics for the `par` function.  We designed it to randomly choose between a set of commands (implicit threads) and evaluate the command list a single step recursively.  After each step, the interpreter would be back to randomly choosing a command branch.  In this way we could interleave commands at a more granular level and simulate multiple branches of code running in parallel.

There must be a duality with the par function however, which is the user's ability to constrain parallel evaluation, an ability to tell the interpreter that a certain region of code may not be parallelized, or must be run sequentially, in an uninteruptible fashion.  We adopted the operator \texttt{atomic} for this purpose.  The user simply uses the \texttt{atomic} keyword followed by a Racket list of expressions.  If the interpreter sees the atomic keyword it circumvents the parallel choice and continues until the list of expressions have been evaluated.

\subsubsection{Interpreter}
There is a subtle distinction between providing the semantics for concurrent programming language and simulating its behavior.  We thus note the difference between the pattern matching rules we provide for our syntax and the interpreter which selects expressions of code to evaluate.  The interpreter implements a simple ``scheduler'' which in our case is a random choice among expressions.  By providing an interpreter ourselves, we gain the ability to run example code sequences.  Without such a function, we would have to manually construct a given ``run'' of the code.

\subsection{Rosette Integration}
Rosette takes expressions in the DSL annotated with Rosette constructs for symbolic variables.  The annotated code is then lifted into Rosette's internal language that affords functions for common tasks utilizing SMT solvers.  The three most common are solving, verification, and synthesis.  In the ``solve'' case, the user code has expressions replaced with symbolic variables, and is additionally given an assertion for what the code should do or compute down to. Rosette uses the backend SMT solver to find values for the symbolic variables to evaluate the expressions in a way that satisfies the assertion.  It can be thought of as a simplistic form of synthesis.  For the ``verify'' case, Rosette looks for a way to fill in the symbolic variables to find a counterexample to the user code's assertion. Finally, in the ``synthesis'' case, the user code is additionally given ``holes'' replacing whole expressions along with a specification for behavior.  Rosette employs its solver to find candidate expressions in the DSL for the holes that mantain the specification.  We found Rosette readily capable of solving and verifying expressions.  Unfortunately, we were not able to synthesize program holes with Rosette.

\subsubsection{Solving and Verification}

\subsubsection{Synthesis}

\subsection{The Midterm Example}
The midterm example throughout is based on a similar example written in C for the CS170 class.  The example there is designed to show that there is a data race for the integer assignment in thread 1 that is not locked by the mutex.  Technically, it is possible for thread 1 to being the integer assigment expression, then because it accesses data outside of a mutex, it could be pre-empted, or interrupted, by thread 2, which begins modifying the data inside its own locked region.  Thread 1, when it regains control of the cpu, will begin a logical line down from the initial line and so the integer assignment will be lost.  This suggests at least two possible pathways for the code.  In fact there are 3, with the third following the above logic but for the opposite interruption scheme.

\begin{table*}[!htbp]
\centering
\begin{tabular}{ r l r l }
\emph{Arithmetic Expression} & $e$ & $::=$ & $e + e$ 
                                         $|$ $e - e$ 
                                         $|$ $e * e$ 
                                         $|$ $v$ 
                                         $|$ $n$ \\
\emph{Boolean Expression} & $b$ & $::=$ & $\neg$ $b$ 
                                      $|$ $b \wedge b$ 
                                      $|$ $e = e$ 
                                      $|$ $e \leq e$ 
                                      $|$ true 
                                      $|$ false \\
\emph{Command} & $c$ & $::=$ & $v$ $:=$ $e$ 
							 $|$   \texttt{load} $g$ $v$
							 $|$   \texttt{store} $v$ $g$ \\ 
               &     &       $|$ & if $b$ then $c$ else $c$
                             $|$   while $b$ do $c$ \\
               &     &       $|$ & $c$ ; $c$
							 $|$   \texttt{atomic} $c$
							 $|$   \texttt{par} $c$
							 $|$   \texttt{skip}
							 $|$   \texttt{halt} 
                               \\
\emph{Local Variables} & $v$ & $\in$ & $\mathcal{V}$ \\
\emph{Global Variables} & $g$ & $\in$ & $\mathcal{G}$ \\
\emph{Integer} & $n$ & $\in$ & $\mathbb{Z}$ \\
\end{tabular}
\caption{
Concurrent Imp DSL grammar. 
}
\label{tab:dsl}
\end{table*}

\begin{figure}[!htbp]
%\begin{empheq}{align*}
\begin{align*}
\frac{\langle S_1 , s \rangle \Rightarrow \langle S_1' , s' \rangle}
	 {\langle S_1 \texttt{ par } S_2, s \rangle \Rightarrow \langle S_1' \texttt{ par } S_2, s' \rangle}
	 \textsc{Par}^1 
\\
\\
\frac{\langle S_1 , s \rangle \Rightarrow s' \rangle}
     {\langle S_1 \texttt{ par } S_2, s \rangle \Rightarrow \langle S_2, s' \rangle}  
	 \textsc{Par}^2
\end{align*}
%\end{empheq}
\caption{Semantics for the concurrent Imp DSL.
}
\label{fig:par-rules}
\end{figure}
