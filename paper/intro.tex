\section{Introduction}
Systems which require multiple processes and threads tend to rely on a classic suite of synchronization tools, including locks, mutexes, condition variables, monitors, and semaphores.  Synchronization refers to using these primitives in a way that prevents data races, race conditions, staleness, and any other problems that might stem from distinct pieces of code trying to modify the same region of data in an unstructured way.  Unfortunately, writing synchronization code is difficult and error-prone.  Programmers have susbequently researched ways of automatically generating synchronization code based on a higher-level understanding of the intended behavior.  This field of research is known as \emph{program synthesis} and is often done through the use of SMT sovlers or other logical specification tools.  In this paper we build a concurrent, imperative programming language to study program synthesis with the aid of the Rosette program synthesis framework \citep{torlak2014}.  We demonstrate how to design and implement such a language in the Racket programming language and use the Rosette framework to perform a set of basic synthesis tasks.

\subsection{Motivation}
\cite{ferles2018} explored synthesizing explicit signal monitors for multithreaded code in Java. Such monitors use condition variables to update locks to communicate with other threads working on shared memory. Using automated program synthesis ensures that the generated synchronization code is correct and, ideally, optimized.  Based on our experiences in the CS170 Operating Systems class, which uses semaphores extensively, we were interested specifically in synthesizing semaphores for basic concurrent code.  Given a simple threaded implementation of a multiple-reader -multiple-writer queue, we wanted to state a simple, high-level description of the behavior---e.g., that two writers may not both push to the queue at the same time, but multiple readers could pop, and generate code with the corresponding counting semaphores.  This requires a specification language, as well as some type of semantics the Rosette framework can use to build in semaphores where it deems appropriate.

\subsection{Contributions}
Our concurrent, imperative programming language is able to simulate parallel executions of multithreaded code, as well as give the user a synchronization primitive, similar to a mutex, to lock code from being interrupted by other threads.  We are able to pass this to the Rosette library with bits of user code replaced by Rosette's symbolic values, and can perform basic solver-based queries on the code.  These queries include making assertions about the end state of the program and having Rosette provide assignments for the symbolic values so that the assertion is satisfied, or alternatively find a counterexample to the assertion (assuming it was invalid).  We were not able, however, to replace portions of our code with Rosette's ``holes'' and replace those holes with syntactic expressions from our input language.  We discuss these results in the Evaluation section.
