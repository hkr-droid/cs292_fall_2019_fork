\section{Introduction}

Writing synchronization code is difficult and error-prone. There has been research about synthesizing explicit signal monitors for multithreaded code in Java \cite{ferles2018}. Such monitors use condition variables to update locks to communicate with other threads working on shared memory. Using automated program synthesis ensures that the generated synchronization code is correct and, ideally, optimized.  Condition variables and monitors (frequently built around mutexes) are only one method in the classic suite of concurrency and multithreaded code. Another commonly used option is semaphores, which by folklore wisdom are considered mutually expressive with monitors (each can implement the other).  We would like to adapt the approach in \cite{ferles2018} to synthesize semaphores instead of monitors.  Based on this we would like to study both performance (how generated semaphores compare to monitors) and semantics, hopefully aiming to prove soundness and completeness of our approach.  It is important for providing formal evidence about the relationship of monitors and semaphores, as well as possibly instructive in generating correct and more performant multithreaded code.

\subsection{Motivation}
There are two tasks in \cite{ferles2018} that do not perform well under the synthesized explicit monitors approach, the Dining Philosophers problem under high concurrency and the H2O Barrier benchmark under low concurrency.  The methodology in \cite{ferles2018} synthesizes explicit monitors to solve the task, which are easier to synthesize correctly, but generate code with worse performance than comparable hand-written code.  We would like to see if we encounter the same problems after switching from monitors to semaphores, or if the underlying problem of generating suboptimal code holds.  We would also like to investigate how the choice of concurrency scheme affects the problems one can solve, and how varying the concurrency scheme changes the logical encoding of the problem, such as the invariants used. 

\subsection{Challenges}
We need to write code to generate semaphores, as well as adapt \cite{ferles2018}â€™s method for generating invariants used in Hoare triples. This will involve understanding and translating the semantics of semaphores into an encoding that a constraint-based solver can understand, which is a non-trivial encoding task. Investigating the semantics of both semaphores and explicit monitors may also tax our knowledge of proving properties such as soundness and completeness.  Most likely we will only be able to synthesize semaphores for a subset of concurrency problems, and so we may have to focus on a single, particular problem, such as Dining Philosophers, as opposed to a more general tool.

