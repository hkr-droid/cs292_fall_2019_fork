\section{Conclusion}
At the conclusion of the CS292C class, we extended the toy language Imp by providing language constructs for executing commands in parallel as well as dually preventing parallel execution for specific regions.  The parallelism is based on the ability to interleave single steps of execution of expressions based on non-deterministic choice.  Reflecting a central tension language designers face, between incorporating functionality into the host, or meta-, language and the object language, we chose to write a minimalistic interpreter for the language which implemented the non-deterministic choice between expressions.  The interpreter gave us the ability to run our code as well as instrument it with Rosette.  We could not get synthesis to work with our toy language, due to our sparse knowledge of Rosette internals and lack of documentation, as well as due to a possible gap in semantic information about our language that we could even provide to Rosette.  We have however identified ways forward to ultimately make synthesis for \texttt{conimp} go through.

\subsection{Future Work}
Going forward with this work, the main goal is to get synthesis working.  To that end, there are two obstacles that must be addressed.  The first is our lack of familiarity with the internals of Rosette.  The error messages Rosette gives often amount to ``unsat'', without any instrumentation context or traceback as to what was happening internally that caused this outcome.  To some extent this is a feature of Racket as well, namely that as a fairly minimal language based off the lambda calculus, a lot of the errors amount to the unhelpful observation that ``application: is not a procedure.''  The second obstacle is the current absence of a logical specification language for our program, or a more detailed semantics about how things {\em should} behave.  There is work by E. Allen Emerson in this field.  In \cite{emerson2011}, E. Allen Emerson and Roopsha Samanta adopt the approach of specifying regions of code as state in a finite-state automaton where the regions are one of ``non-critical'', ``trying'', and ``critical''.  These regions are considered states in the graph while the edges between them reflect code sequencing and are annotated by logical formulas.  The formulas specify properties such as ``deadlock free''.  We would like to adopt this strategy as our specification language; however, it represents a substantial amount of developer time.

If we can get synthesis working, it would finally be possible to write a backend component of our project which mechanically translates synthesized code into the C language.  This would further enable evaluation of generated code against hand-written code from the CS170 class as well as classic problems in concurrency.  Most likely, this would be based on translating synthesized structures into \texttt{pthreads} implementations for locks and mutexes, and the class's \texttt{kthreads} library for semaphores.  There is further work to be addressed in synthesizing non-preemptive versus preemptive threading code.  We think there is utility in pursuing the project to this point, both as an educational tool for the operating systems class, as well as for operationalizing the Emerson and Samanta semantics, to determine if this is a viable method for synthesizing concurrent code for non-trivial software tasks.
